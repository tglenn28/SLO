%_________________________________________________________________________
%   Fixed Lag Smoother Using Cocurrent Filtering and Smoothing
%
%_________________________________________________________________________
%   Course: EECS 568
%   Author: Ali Badreddine
%   Date: 04/18/2020
%_________________________________________________________________________

function [Results] = AliConcurrent(lag, priorNoise, Noise, icp)

%input lag ex: lag = 2,5,10
%input priorNoise & Noise sigmas in the following format ex: [0.1; 0.1; 0.1; 0.1; 0.1; 0.1];
%return filter results at said key/pose; run the blow two lines:
%   Results = concurrentFilter.calculateEstimate;
%   Results.atPose3(currentKey)

import gtsam.*;
import gtsam_unstable.*;

%% Read data
[edges_gicp_sort, edges_gicp_con, edges_gicp_non, edges_sicp_sort, edges_sicp_con, edges_sicp_non, T_Pose_GT] = AliloadTransformations('transformations&GT.mat');
% Define the smoother lag (in seconds)

if icp == "gicp"
    edges_con = edges_gicp_con;
    edges_non = edges_gicp_non;
elseif icp == "sicp"
    edges_con = edges_sicp_con;
    edges_non = edges_sico_non;
else
    msg = 'Please specify data generated by either gicp or sicp.';
    error(msg)
end


% Create a Concurrent Filter and Smoother
concurrentFilter = ConcurrentBatchFilter;
concurrentSmoother = ConcurrentBatchSmoother;

%% Create containers to store the factors and linearization points that
% will be sent to the smoothers
newFactors = NonlinearFactorGraph;
newValues = Values;

%% Create a prior on the first pose, placing it at the origin
%Initialize estimate

previousKey = uint64(0);

%Utilize ground truth to define prior
pose3 = Pose3([reshape(T_Pose_GT(1,2:end),4,3)'; 0 0 0 1]);
newValues.insert(previousKey, pose3);

%Define Noise and priorNoise
priorNoise = noiseModel.Diagonal.Sigmas(priorNoise);
Noise = noiseModel.Diagonal.Sigmas(Noise);

%create graph contain & add prior
newFactors.add(PriorFactorPose3(previousKey, pose3, priorNoise));

%% Insert the prior factor into the filter
concurrentFilter.update(newFactors, newValues);

%% Find next pose
nextKey = 1;
result = concurrentFilter.calculateEstimate();
NextPose = result.atPose3(previousKey);

%% Now, loop through several time steps, creating factors from different "sensors"
% and adding them to the fixed-lag smoothers
deltaT = 1;

for time = deltaT : deltaT : length(edges_con)
    %% Initialize factor and values for this loop iteration
    newFactors = NonlinearFactorGraph;
    newValues = Values;
    
    %% Define the keys related to this timestamp
    previousKey = time-deltaT;
    currentKey = time;
    nextKey = time+deltaT;
    
    %% Add current pose to the new values
    newValues.insert(currentKey, NextPose);
    
    %% Add odometry factors from two incremental sources with different error stats
    pose3 = findSE3(edges_con(currentKey,:));
    
    newFactors.add(BetweenFactorPose3(previousKey,currentKey, pose3, Noise));
    
    %% Unlike the fixed-lag versions, the concurrent filter implementation
    % requires the user to supply the specify which keys to move to the smoother
    oldKeys = KeyList;
    if time >= lag+deltaT
        oldKeys.push_back(time-lag-deltaT);
        key_track_start = time-lag;
    end
    
    %% Update the various inference engines
    concurrentFilter.update(newFactors, newValues, oldKeys);
    
    result = concurrentFilter.calculateEstimate();
    NextPose = result.atPose3(currentKey);
    
    %% Add a loop closure to the smoother at a particular time
    
    if time == floor(length(edges_con)/2)
        % Synchronize the Filter and Smoother
        concurrentSmoother.update();
        synchronize(concurrentFilter, concurrentSmoother);
        smootherFactors = NonlinearFactorGraph;
        
        for i = 1:floor(length(edges_con)/2)-lag
            smootheredges = edges_non(edges_non(:,1)==i,:);
            Pose3(edges_con(1,3:18))
            for j = 1: size(smootheredges,1)
                lidar_poses = [result.atPose3(previousKey).x result.atPose3(previousKey).y result.atPose3(previousKey).z];
                
                pose3 = findSE3(smootheredges(j,:));
                smootherFactors.add(BetweenFactorPose3(smootheredges(j,2),smootheredges(j,1), pose3, Noise));
                
            end
            
        end
        
        concurrentSmoother.update(smootherFactors, Values());
        
    elseif time == length(edges_con)
        
        % Synchronize the Filter and Smoother
        concurrentSmoother.update();
        synchronize(concurrentFilter, concurrentSmoother);
        smootherFactors = NonlinearFactorGraph;
        
        for i = (floor(length(edges_con)/2) + 1):length(edges_con)-lag
            smootheredges = edges_non(edges_non(:,1)==i,:);
            Pose3(edges_con(1,3:18))
            for j = 1: size(smootheredges,1)
                lidar_poses = [result.atPose3(previousKey).x result.atPose3(previousKey).y result.atPose3(previousKey).z];
                
                pose3 = findSE3(smootheredges(j,:));
                smootherFactors.add(BetweenFactorPose3(smootheredges(j,2),smootheredges(j,1), pose3, Noise));
                
            end
            
        end
        
        concurrentSmoother.update(smootherFactors, Values());
        
    end
    
    %% Print the filter optimized poses
    fprintf(1, 'Timestamp = %5.3f\n', time);
    filterResult = concurrentFilter.calculateEstimate;
    filterResult.atPose3(currentKey).print('Concurrent Estimate: ');
    
    Results(currentKey) =  filterResult.atPose3(currentKey);
    
    %% Plot Covariance Ellipses
    cla;
    hold on
    filterMarginals = Marginals(concurrentFilter.getFactors, filterResult);
    plot3DTrajectory(filterResult, 'k*-', filterMarginals);
    
    smootherGraph = concurrentSmoother.getFactors;
    if smootherGraph.size > 0
        smootherResult = concurrentSmoother.calculateEstimate;
        smootherMarginals = Marginals(smootherGraph, smootherResult);
        plot3DTrajectory(smootherResult, 'r*-', smootherMarginals);
    end
    
    axis equal
    axis tight
    view(2)
    pause(0.01)
end

    function cov = findcov(edge,i)
        %find information matrix and make symmetric
        info_vector = [edge.info1(i), edge.info2(i), edge.info3(i), edge.info4(i), edge.info5(i), edge.info6(i), edge.info7(i), edge.info8(i), edge.info9(i), edge.info10(i), edge.info11(i), edge.info12(i), edge.info13(i), edge.info14(i), edge.info15(i), edge.info16(i), edge.info17(i), edge.info18(i), edge.info19(i), edge.info20(i), edge.info21(i)];
        
        l = (-1+sqrt(1+8*length(info_vector)))/2;
        J = tril(ones(l));
        J(J > 0) = info_vector;
        info = (J + J')./(eye(l)+1);
        
        cov=inv(info);
    end


    function pose3 = findSE3(ICP)
        import gtsam.*
        pose3 = Pose3(reshape(ICP(1,3:18),4,4)');
        
    end

end
