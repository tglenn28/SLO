%_________________________________________________________________________
%   Fixed Lag Smoother Using Cocurrent Filtering and Smoothing
%
%_________________________________________________________________________
%   Course: EECS 568
%   Author: Ali Badreddine
%   Date: 04/20/2020
%_________________________________________________________________________

function [Results, smootherResult] = AliConcurrent503aided2(lag, sync, priorNoise, Noise, icp, non_con, datapath, printresult, loopclosures)

%input lag ex: lag = 2,5,10
%input priorNoise & Noise sigmas in the following format ex: [0.1; 0.1; 0.1; 0.1; 0.1; 0.1];
%return filter results at said key/pose; run the blow two lines:
%   Results = concurrentFilter.calculateEstimate;
%   Results.atPose3(currentKey)

import gtsam.*;
import gtsam_unstable.*;

%% Read data
[edges_gicp_con, edges_gicp_non, cov_gicp_con, cov_gicp_non, edges_sicp_con, edges_sicp_non, cov_sicp_con, cov_sicp_non, T_Pose_GT] = AliloadTransformations03(datapath);
% Define the smoother lag (in seconds)

if icp == "gicp"
    edges_con = edges_gicp_con;
    edges_non = edges_gicp_non;
    cov_con = cov_gicp_con;
    cov_non = cov_gicp_non;
    color = 'c*-';
elseif icp == "sicp"
    edges_con = edges_sicp_con;
    edges_non = edges_sicp_non;
    cov_con = cov_sicp_con;
    cov_non = cov_sicp_non;
    color = 'teal*-';
else
    msg = 'Please specify data generated by either gicp or sicp.';
    error(msg)
end

edges_aided2 = edges_non(edges_non(:,size(edges_non,2))==2,:);

edges_non = edges_non(edges_non(:,size(edges_non,2))>=non_con,:);

% edges_non = datasample(cov_non,200);

% Create a Concurrent Filter and Smoother
concurrentFilter = ConcurrentBatchFilter;
concurrentSmoother = ConcurrentBatchSmoother;

%% Create containers to store the factors and linearization points that
% will be sent to the smoothers
newFactors = NonlinearFactorGraph;
newValues = Values;

%% Create a prior on the first pose, placing it at the origin
%Initialize estimate

previousKey = uint64(0);

%Utilize ground truth to define prior
pose3 = Pose3([reshape(T_Pose_GT(1,2:end),4,3)'; 0 0 0 1]);
newValues.insert(previousKey, pose3);

%Define Noise and priorNoise
priorNoise = noiseModel.Diagonal.Sigmas(priorNoise);
Noise = noiseModel.Diagonal.Sigmas(Noise);

%create graph contain & add prior
newFactors.add(PriorFactorPose3(previousKey, pose3, priorNoise));

%% Insert the prior factor into the filter
concurrentFilter.update(newFactors, newValues);

%% Find next pose
nextKey = 1;
result = concurrentFilter.calculateEstimate();
NextPose = result.atPose3(previousKey);

%% Now, loop through several time steps, creating factors from different "sensors"
% and adding them to the fixed-lag smoothers
deltaT = 1;
synctime = 0;
previousSKey = 0;

%% loop closure 
if loopclosures ~= 0
loopclosures = sortrows(loopclosures,1);
minloop = loopclosures(1,1);
minloopidx = 1;
maxloopcount = size(loopclosures,1);
count = 1;
else 
minloop = 0;
end

for time = deltaT : deltaT : length(edges_con)
    %% Initialize factor and values for this loop iteration
    newFactors = NonlinearFactorGraph;
    newValues = Values;
    
    %% Define the keys related to this timestamp
    previousKey = time-deltaT;
    currentKey = time;
    nextKey = time+deltaT;
    
    %% Add current pose to the new values
    newValues.insert(currentKey, NextPose);
    
    %% Add odometry factors from two incremental sources with different error stats
    pose3 = findSE3(edges_con(currentKey,:));s
        
    newFactors.add(BetweenFactorPose3(previousKey,currentKey, pose3, Noise));
    
    
    %%%%%%%%%%%%%%%%%%%%%
    pose3_sicp = findSE3(edges_sicp_con(currentKey,:));
        
    newFactors.add(BetweenFactorPose3(previousKey,currentKey, pose3_sicp, Noise));
    
    
    
%     if currentKey <= (length(edges_con)-2)% Tr =   [2.347736981471e-04 -9.999441545438e-01 -1.056347781105e-02 -2.796816941295e-03;
%     1.044940741659e-02 1.056535364138e-02 -9.998895741176e-01 -7.510879138296e-02;
%     9.999453885620e-01 1.243653783865e-04 1.045130299567e-02 -2.721327964059e-01;
%     0                   0                   0                   1];
% 
% import gtsam.*
% for i = 1:length(edges_sic)
% pose3 = (Tr * reshape(edges_sic(i,3:18),4,4)') / Tr;
% 
% edges_sic(i,3:18) = pose3(:)';
% end
% 
% for i = 1:length(edges_gicp)
% pose3 = (Tr * reshape(edges_gicp(i,3:18),4,4)') / Tr;
% 
% edges_gicp(i,3:18) = pose3(:)';
% end

%     
%     pose3aided = findSE3(edges_aided2(currentKey,:));
%     
% %   Noise = noiseModel.Gaussian.Covariance(reshape(cov_con(currentKey,3:end-1),6,6)');
%     
%     newFactors.add(BetweenFactorPose3(previousKey,currentKey, pose3aided, Noise));
%     
%     end 
    
%         if currentKey <= (length(edges_con)-3)
%     
%     pose3aided = findSE3(edges_aided3(currentKey,:));
%     
% %   Noise = noiseModel.Gaussian.Covariance(reshape(cov_con(currentKey,3:end-1),6,6)');
%     
%     newFactors.add(BetweenFactorPose3(previousKey,currentKey, pose3aided, Noise));
%     
%         end 
%     
%             if currentKey <= (length(edges_con)-4)
%     
%     pose3aided = findSE3(edges_aided4(currentKey,:));
%     
% %   Noise = noiseModel.Gaussian.Covariance(reshape(cov_con(currentKey,3:end-1),6,6)');
%     
%     newFactors.add(BetweenFactorPose3(previousKey,currentKey, pose3aided, Noise));
%     
%     end 
    
    %% Unlike the fixed-lag versions, the concurrent filter implementation
    % requires the user to supply the specify which keys to move to the smoother
    oldKeys = KeyList;
    if time >= lag+deltaT
        oldKeys.push_back(time-deltaT-lag);
%         key_track_start = time-lag;
    end
    
    %% Update the various inference engines
    concurrentFilter.update(newFactors, newValues, oldKeys);
    
    result = concurrentFilter.calculateEstimate();
    NextPose = result.atPose3(currentKey);
    
    %% Add a loop closure to the smoother at a particular time
        
    if synctime == sync || time == length(edges_con)
        
        concurrentSmoother.update();
        synchronize(concurrentFilter, concurrentSmoother);
        smootherFactors = NonlinearFactorGraph;
        
        currentSKey = currentKey-lag;
        
%         for i = previousSKey:currentSKey
%             smootheredges = edges_non(edges_non(:,1)==i,:);
% %             smoothercov = cov_non(edges_non(:,1)==i,:);
%             
%             Pose3(edges_con(1,3:18))
%             for j = 1: size(smootheredges,1)
%                 %                 lidar_poses = [result.atPose3(previousKey).x result.atPose3(previousKey).y result.atPose3(previousKey).z];
%                 
% %                 Noise = noiseModel.Gaussian.Covariance(reshape(smoothercov(j,3:end-1),6,6)');
%                 
%                 pose3 = findSE3(smootheredges(j,:));
%                 smootherFactors.add(BetweenFactorPose3(smootheredges(j,2),smootheredges(j,1), pose3, Noise));
%                 
%             end
%             
%         end
        
        %APPLY additional loop closure if inputed in the function
        if minloop ~= 0 && minloop == currentKey && count <= maxloopcount
            
            pose3 = findSE3(loopclosures(minloopidx,:));
            smootherFactors.add(BetweenFactorPose3(loopclosures(minloopidx,2),smootheredges(minloopidx,1), pose3, Noise));
            
            minloopidx = minloopidx +1;
            count = count +1;
            minloop = loopclosures(minloopidx,1);
            
        end        
    
        concurrentSmoother.update(smootherFactors, Values());
        
        previousSKey = currentSKey;
        synctime = 0;
    end
    synctime = synctime+1;
     
    %add additional loop closures inputed by the use

    %% Print the filter optimized poses
    fprintf(1, 'Timestamp = %5.3f\n', time);
    filterResult = concurrentFilter.calculateEstimate;
    filterResult.atPose3(currentKey).print('Concurrent Estimate: ');
    
    Results(currentKey) =  filterResult.atPose3(currentKey);
    
    %% Plot Covariance Ellipses
    cla;
    hold on
%     filterMarginals = Marginals(concurrentFilter.getFactors, filterResult);
%     plot3DTrajectory(filterResult, 'k*-', filterMarginals);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
plot3DTrajectory(filterResult, 'k*-');

    
    smootherGraph = concurrentSmoother.getFactors;
    if smootherGraph.size > 0
        smootherResult = concurrentSmoother.calculateEstimate;
%         smootherMarginals = Marginals(smootherGraph, smootherResult);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        plot3DTrajectory(smootherResult, color);
%         plot3DTrajectory(smootherResult, 'r*-', smootherMarginals);
    end
    
    axis equal
    axis tight
    view(2)
    pause(0.01)
end

if printresult == 1

tempText = "FilterResults" + lag + "_" + sync + "_" + non_con + icp + ".mat";

save(tempText, 'Results');

tempText = "SmootherResults" + lag + "_" + sync + "_" + non_con + icp + ".mat";

save(tempText, 'smootherResult');

tempText = "ConResults" + lag + "_" + sync + "_" + non_con + icp + ".fig";

saveas(gcf,tempText);

end

    function cov = findcov(edge,i)
        %find information matrix and make symmetric
        info_vector = [edge.info1(i), edge.info2(i), edge.info3(i), edge.info4(i), edge.info5(i), edge.info6(i), edge.info7(i), edge.info8(i), edge.info9(i), edge.info10(i), edge.info11(i), edge.info12(i), edge.info13(i), edge.info14(i), edge.info15(i), edge.info16(i), edge.info17(i), edge.info18(i), edge.info19(i), edge.info20(i), edge.info21(i)];
        
        l = (-1+sqrt(1+8*length(info_vector)))/2;
        J = tril(ones(l));Tr
        J(J > 0) = info_vector;
        info = (J + J')./(eye(l)+1);
        
        cov=inv(info);
    end


    function pose3 = findSE3(ICP)
        
        Tr =   [2.347736981471e-04 -9.999441545438e-01 -1.056347781105e-02 -2.796816941295e-03;
        1.044940741659e-02 1.056535364138e-02 -9.998895741176e-01 -7.510879138296e-02;
        9.999453885620e-01 1.243653783865e-04 1.045130299567e-02 -2.721327964059e-01;
        0                   0                   0                   1];
    
        import gtsam.*
        pose3 = Pose3((Tr * reshape(ICP(1,3:18),4,4)') / Tr);
        
    end

end
